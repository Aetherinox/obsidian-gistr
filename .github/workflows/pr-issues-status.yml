# ---------------------------------------------------------------------------------------
#   @parent     : github workflow
#   @desc       : checks each issue / PR for a valid label
#   @author     : Aetherinox
#   @url        : https://github.com/Aetherinox
#
#   This Github action must be activated manually.  This workflow script will do the
#   following:
#
#       - Scan issues / pull requests and make sure they have properly assigned labels:
#           - `Bug`
#           - `Feature`
#           - `Urgent`
#           - `Roadmap`
#
#       - Workflow script will then scan each pr or issue and mark them as `Stale` 
#         if they haven't had any replies in 30 days.
#
#       - Workflow will `autoclose` pr or issues which haven't had action in `365 days`.
# ---------------------------------------------------------------------------------------

name: "üé´ Issues + PR ‚Ä∫ Status"
run-name: "üé´ Issues + PR ‚Ä∫ Status"

# ---------------------------------------------------------------------------------------
#   triggers
# ---------------------------------------------------------------------------------------

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */2 * * *"

# ---------------------------------------------------------------------------------------
#   environment variables
# ---------------------------------------------------------------------------------------

env:
  PREFIX_BUG:           "Bug"
  PREFIX_FEATURE:       "Feature"
  PREFIX_ROADMAP:       "Roadmap"
  PREFIX_DEPENDENCY:    "Dependency"
  PREFIX_PR:            "PR"
  PREFIX_DOCS:          "Docs"
  PREFIX_GIT:           "Git Action"
  PREFIX_URGENT:        "Urgent"

  LABEL_BUG:            "Type ‚á¥ Bug"
  LABEL_FEATURE:        "Type ‚á¥ Feature"
  LABEL_ROADMAP:        "Type ‚á¥ Roadmap"
  LABEL_DEPENDENCY:     "Type ‚á¥ Dependency"
  LABEL_PR:             "Type ‚á¥ PR"
  LABEL_DOCS:           "Type ‚á¥ Docs"
  LABEL_GIT:            "Type ‚á¥ Git Action"
  LABEL_URGENT:         "‚ö† Urgent"

  ASSIGN_USER:          Aetherinox
  BOT_NAME_1:           AdminServ
  BOT_NAME_2:           AdminServX
  BOT_NAME_DEPENDABOT:  dependabot[bot]
  LABELS_JSON: |
    [
      { "name": "Type ‚á¥ Bug",             "color": "9a2c2c", "description": "Something isn't working" },
      { "name": "Type ‚á¥ Feature",         "color": "F62735", "description": "Feature request" },
      { "name": "Type ‚á¥ Roadmap",         "color": "8F1784", "description": "Feature or bug currently planned for implementation" },
      { "name": "Type ‚á¥ Dependency",      "color": "243759", "description": "Item is associated to dependency" },
      { "name": "Type ‚á¥ PR",              "color": "8F1784", "description": "Item is marked as a Pull Request" },
      { "name": "Type ‚á¥ Docs",            "color": "0e588d", "description": "Improvements or modifications to docs" },
      { "name": "Type ‚á¥ Git Action",      "color": "030406", "description": "Pull requests that update GitHub Actions code" },
      { "name": "Status ‚ÜØ Locked",        "color": "550F45", "description": "This item was automatically locked by AdminServ for a prolonged period of inactivity" },
      { "name": "Status ‚ÜØ Review",        "color": "6E465A", "description": "This item is currently pending review" },
      { "name": "Status ‚ÜØ Stale",         "color": "FFFFFF", "description": "This issue has not received any responses in over 30 days" },
      { "name": "Status ‚ÜØ Autoclosed",    "color": "3E0915", "description": "This issue was originally stale and was autoclosed for no activity" },
      { "name": "Status ‚ÜØ Released",      "color": "1b6626", "description": "Issues or PR has been implemented and is now live" },
      { "name": "Status ‚ÜØ Accepted",      "color": "2e7539", "description": "This pull request has been accepted" },
      { "name": "Status ‚ÜØ Review",        "color": "9e1451", "description": "Item is currently pending review" },
      { "name": "Status ‚ÜØ Denied",        "color": "ba4058", "description": "Pull request has been denied" },
      { "name": "Status ‚ÜØ Need Info",     "color": "2E3C4C", "description": "Not enough information to resolve" },
      { "name": "Status ‚ÜØ No Action",     "color": "030406", "description": "This request was closed without any action being taken" },
      { "name": "Status ‚ÜØ Pending",       "color": "D5155E", "description": "Pending pull request" },
      { "name": "Status ‚ÜØ Reopened",      "color": "B78D03", "description": "A previously closed PR which has been re-opened" },
      { "name": "‚ö† Urgent",              "color": "a8740e", "description": "Requires urgent attention" },
      { "name": "AC/Failed",              "color": "d73a4a", "description": "Autocheck failed to run through a complete cycle, requires investigation" },
      { "name": "AC/Changes Required",    "color": "36552B", "description": "The PR requires changes to be made to the package before it will be accepted" },
      { "name": "AC/Passed",              "color": "ccb11d", "description": "PR is ready to be reviewed by primary developer" },
      { "name": "AC/Review Required",     "color": "8F1784", "description": "PR needs to be reviewed by another person, after the currently requested changes have been made" },
      { "name": "AC/Needs Rebase",        "color": "8F1784", "description": "Due to the permissions on the requesting repo, this pull request must be rebased by the author" },
      { "name": "AC/Security Warning",    "color": "8F1784", "description": "Pull request contents does not conform to developer policies, or includes potentially dangerous code" },
      { "name": "AC/Changes Made",        "color": "8F1784", "description": "The requested changes have been made and is pending a re-scan" },
      { "name": "AC/Skipped Scan",        "color": "8F1784", "description": "Code scanning skipped because PR author believes result is wrong" }
    ]

jobs:

  # ---------------------------------------------------------------------------------------
  #   Verify Existing Labels
  #   This job will ensure you have labels already created in your repo.
  #
  #   All labels come from the JSON table LABELS_JSON.
  # ---------------------------------------------------------------------------------------

  issues-labels-create:
    name: üé´ Labels ‚Ä∫ Verify Existing
    runs-on: ubuntu-latest
    steps:

      - name: "‚úÖ Start"
        run: | 
              echo "Assigning labels and assignees"

      # ---------------------------------------------------------------------------------------
      #   checkout
      # ---------------------------------------------------------------------------------------

      - name: "‚òëÔ∏è Checkout"
        id: issues-labels-create-checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------------------------------------------------------------------
      #   Check if repo has labels currently added to issues
      # ---------------------------------------------------------------------------------------
        
      - name: üè∑Ô∏è Verify Existing Labels
        id: issues-labels-create-verify
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMINSERV_TOKEN_CL }}
          script: |
            const labels = JSON.parse( process.env.LABELS_JSON );
            for ( const label of labels )
            {
                try
                {
                    await github.rest.issues.createLabel(
                    {
                        owner:        context.repo.owner,
                        repo:         context.repo.repo,
                        name:         label.name,
                        description:  label.description || '',
                        color:        label.color
                    });
                }
                catch ( err )
                {
                    if ( err.status === 422 )
                    {
                        console.log( `Label '${label.name}' already exists. Skipping.` );
                    }
                    else
                    {
                        console.error( `Error creating label '${label.name}': ${err}` );
                    }
                }
            }
  
  # ---------------------------------------------------------------------------------------
  #   Runs through all submissions to check for ones that have not been properly labeled
  #       - Bug
  #       - Feature
  #       - Urgent
  #       - Roadmap
  # ---------------------------------------------------------------------------------------
            
  issues-labels-check:
    name: üé´ Labels ‚Ä∫ Assign Missing
    runs-on: ubuntu-latest
    needs: issues-labels-create
    steps:

      # ---------------------------------------------------------------------------------------
      #   checkout
      # ---------------------------------------------------------------------------------------

      - name: "‚òëÔ∏è Prepare"
        id: issues-labels-check-checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------------------------------------------------------------------
      #   Check if repo has labels currently added to issues
      # ---------------------------------------------------------------------------------------
        
      - name: üè∑Ô∏è Checking Issues
        id: issues-labels-check-run
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMINSERV_TOKEN_CL }}
          script: |
        
            /*
                Date/Time
            */

            const dateTimeformat = ( date ) =>
            {
                let month           = date.getMonth( ) + 1;
                month               = month.toString( ).padStart( 2, '0' );
                let day             = date.getDate( ).toString( ).padStart( 2, '0' );
                let year            = date.getFullYear( ).toString( ).padStart( 2, '0' );

                let hours           = date.getHours();
                let minutes         = date.getMinutes();
                let x               = hours >= 12 ? 'PM' : 'AM';
                hours               = hours % 12;
                hours               = hours ? hours : 12;
                minutes             = minutes.toString( ).padStart( 2, '0' );

                let mergeTime   = month + '.' + day + '.' + year + ' ' + hours + ':' + minutes + ' ' + x;

                return mergeTime;
            }

            /*
                Change last number ( 36 = hours )
            */

            const expireAfterMs     = 1000 * 60 * 60 * 36;        // milliseconds ( 36 hours )
            const curtime           = new Date( ).getTime( );     // 1711471510629
            const issues            = await github.rest.issues.listForRepo( { owner: context.repo.owner, repo: context.repo.repo, state: 'open' } );
  
            console.log( `  üì¶‚îÄ‚îÄ  Found ${issues.data.length} open issues` );

            for ( const issue of issues.data )
            {

                let date_UpdateDate     = new Date( `${ issue.updated_at }` ?? `${ issue.created_at }` );   // Tue Mar 26 2024 16:40:41 GMT+0000 (Coordinated Universal Time)
                date_UpdateDate.toISOString( )                                                              // Tue Mar 26 2024 16:40:41 GMT+0000 (Coordinated Universal Time) (string)

                let date_UpdateHuman    = dateTimeformat( date_UpdateDate ) + " UTC";                       // 03.26.2024 4:40 PM UTC
                const time_UpdateMs     = new Date( issue.updated_at ).getTime( );                          // 1711471241000

                //if ( curtime < time_UpdateMs + expireAfterMs ) continue;

                /*
                    Anything past this point is stale / to be closed
                */

                const timeline          = await github.rest.issues.listEventsForTimeline( { owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number } );
                // const labelEvent     = timeline.data.find( event => event.event === 'labeled' && event.label.name === 'status-stale' );

                /*
                    Get Issue Data
                */

                const add_labels        = issue.labels.map( label => label.name );

                let iss_title           = `${ issue.title }`;
                const iss_title_lc      = iss_title.toLowerCase( );

                let iss_body            = `${ issue.body }`;
                const iss_body_lc       = iss_body.toLowerCase( );

                console.log( `      ‚îî‚îÄ‚îÄ üìÅ ` + iss_title );
                console.log( `         ‚îî‚îÄ‚îÄ üìÑ Issue #${ issue.number } last updated on ${ date_UpdateHuman }` );
                console.log( `         ‚îî‚îÄ‚îÄ üìÑ ${add_labels}` );
                console.log( `\n\n` )

                /*
                    Keywords
                */

                const bug_words           = [ "bug", "broke", "issue", "fail" ];
                const feat_words          = [ "feature", "request", "add support" ];
                const urgn_words          = [ "urgent", "urgency", "emergency", "important", "critical" ];
                const road_words          = [ "roadmap", "road map", "planned" ];

                /*
                    Tags
                */

                const bug_tag             = `${{ env.PREFIX_BUG }}:`;
                const bug_lbl             = `${{ env.LABEL_BUG }}`;
                const feat_tag            = `${{ env.PREFIX_FEATURE }}:`;
                const feat_lbl            = `${{ env.LABEL_FEATURE }}`;
                const urgn_tag            = `${{ env.PREFIX_URGENT }}:`;
                const urgn_lbl            = `${{ env.LABEL_URGENT }}`;
                const road_tag            = `${{ env.PREFIX_ROADMAP }}:`;
                const road_lbl            = `${{ env.LABEL_ROADMAP }}`;

                /*
                    Label > Bugs
                */

                const bug_bIncWordT         = bug_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                /*
                    Find regex based phrases
                */
    
                const bug_findWordList 	      = /(?:I?\s*have\s*(?:a|an)\s*(?:issue|problem|bug))|(?:will\s*not\s*work)|(?:it\s*is\s*(?:broken|broke|stuck))|(?:found\s*(?:an?|the)\s*(?:bug|issue))|(?:can\s*I\s*fix\s*the\s*(?:bug|issue))|(?:(?:does not|doesn'?t|don'?t|won'?t|can'?t|can\s?not|will\s*not)\s*(?:work|load|function))|(?:it\s*(?:will\s?not|won'?t|can\s?not|can'?t))\s*get\s*the\s*(?:website|site|webpage|page)|(?:the\s*(?:window|frame)\s*is\s*(?:blank|white|empty|missing))/igm;
                const bug_bFoundMatchTitle    = Boolean( bug_findWordList.test( iss_title ) );
                const bug_bFoundMatchBody     = Boolean( bug_findWordList.test( iss_body ) );
    
                /*
                    Do not change a title if the item starts with a PR: #
                */

                const bug_findPRTitle         = /^PR\s(?:[0-9]*:?)/igm;
                const bug_bFoundPRTitle       = Boolean( bug_findPRTitle.test( iss_title ) );

                /*
                    - Check if issue title matches the issue label "Bug:"
                    - Check if title contains word in containsList 
                */

                if ( iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) || bug_bIncWordT || bug_bFoundMatchTitle || bug_bFoundMatchBody )
                {

                    add_labels.push( `${ bug_lbl }` );

                    // Rename title to contain Bug:
                    if ( !bug_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?bug\s*(.*?)\b/gi, '' );
                        title_new         		= title.replace( /^\s?fail\s*(.*?)\b/gi, '' );
                        title_new         		= title.replace( /^\s?issue\s*(.*?)\b/gi, '' );
                        iss_title             = `${ bug_tag } ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Features
                */

                const feat_bIncWordT      = feat_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                /*
                    Find regex based phrases
                */
    
                const feat_findWordList 	      = /(?:(?:request|include|see)\s*(?:a?|the?)\s*(?:feature|addon|addition|plugin))|(?:(?:add|see|get)\s*support\s*(?:for|with|of))/igm;
                const feat_bFoundMatchTitle     = Boolean( feat_findWordList.test( iss_title ) );
                const feat_bFoundMatchBody      = Boolean( feat_findWordList.test( iss_body ) );

                /*
                    Do not change a title if the item starts with a PR: #
                */

                const feat_findPRTitle          = /^PR\s(?:[0-9]*:?)/igm;
                const feat_bFoundPRTitle        = Boolean( feat_findPRTitle.test( iss_title ) );

                /*
                    - Check if issue title matches the issue label "Feature:"
                    - Check if title contains word in containsList 
                */

                if ( iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) || feat_bIncWordT || feat_bFoundMatchTitle || feat_bFoundMatchBody )
                {

                    add_labels.push( `${ feat_lbl }` );

                    // Rename title to contain Feature:
                    if ( !feat_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?feature\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?request\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?add(.*?)\s?feature\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?add(.*?)\s?support\s*(.*?)\b/gi, '' );
                        iss_title             = `${ feat_tag } ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Urgent
                */

                const urgn_bIncWordT      = urgn_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                /*
                    Find regex based phrases
                */
    
                const urgn_findWordList       = /\b(?:(?:this)?is\s*a?n?\s*?(?:emergency|urgent|important|vital|acute|crucial|grave|pressing|serious|top.?priority|high.?priority))|(?:reply|respond|answer|write|address)\s*(?:immediate|quick|asap|urgent|now|fast|(?:as)?\s*(?:soon|quick|immediate|fast))(?:ly)?|(?:need\s*(?:help|support|fixed|answer|reply|response)!)|(?:emergency|critical|urgen(?:t|cy)|high.?priority)\b/igm;
                const urgn_bFoundMatchTitle   = Boolean( urgn_findWordList.test( iss_title ) );
                const urgn_bFoundMatchBody    = Boolean( urgn_findWordList.test( iss_body ) );

                /*
                    Do not change a title if the item starts with a PR: #
                */

                const urgn_findPRTitle          = /^PR\s(?:[0-9]*:?)/igm;
                const urgn_bFoundPRTitle        = Boolean( urgn_findPRTitle.test( iss_title ) );

                /*
                    - Check if issue title matches the issue label "Urgent:"
                    - Check if title contains word in containsList 
                */

                if ( iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) || urgn_bIncWordT || urgn_bFoundMatchTitle || urgn_bFoundMatchBody )
                {

                    add_labels.push( `${ urgn_lbl }` );

                    // Rename title to contain Urgent:
                    if ( !urgn_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?emergency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgent\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?important\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?critical\s*(.*?)\b/gi, '' );
                        iss_title             = `${ urgn_tag } ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Roadmap
                */

                const road_bIncWordT      = road_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                /*
                    Find regex based phrases
                    Roadmap requires headers #Summary and #Proposal | #Objective
                */
    
                const road_findWordList 	      = /#\s*Summary[\S\s]+#\s*(?:Proposal|Objective)[^\]]+/igm;
                const road_bFoundMatchTitle     = Boolean( road_findWordList.test( iss_title ) );
                const road_bFoundMatchBody      = Boolean( road_findWordList.test( iss_body ) );

                /*
                    Do not change a title if the item starts with a PR: #
                */

                const road_findPRTitle          = /^PR\s(?:[0-9]*:?)/igm;
                const road_bFoundPRTitle        = Boolean( road_findPRTitle.test( iss_title ) );

                /*
                    - Check if issue title matches the issue label "Roadmap:"
                    - Check if title contains word in containsList 
                */

                if ( iss_title_lc.startsWith( road_tag.toLowerCase( ) ) || road_bIncWordT || road_bFoundMatchTitle || road_bFoundMatchBody )
                {

                    add_labels.push( `${ road_lbl }` );

                    // Rename title to contain Roadmap:
                    if ( !road_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?emergency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgent\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?important\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?critical\s*(.*?)\b/gi, '' );
                        iss_title             = `${ road_tag } ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                await github.rest.issues.update(
                {
                    owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                    state: 'closed', state_reason: 'not planned'
                } );
                */
            }

  # ---------------------------------------------------------------------------------------
  #   Check Stale Issues
  # ---------------------------------------------------------------------------------------

  issues-stale-check:
    name: üí§ Stale ‚Ä∫ Mark Submissions
    runs-on: ubuntu-latest
    needs:
      - issues-labels-create
      - issues-labels-check
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
  
    - name: üí§ Stale ‚Ä∫ Check Condition
      uses: actions/stale@v9
      id: issues-stale-check-run
      with:
        repo-token: ${{ secrets.ADMINSERV_TOKEN }}
        stale-issue-message: |
          ‚ö†Ô∏è It looks like there hasn't been any recent updates on this
          issue.  If you created this issue and no longer consider it
          open, then please login to github and close the issue.  
          
          If there is no further activity on this issue, it will be 
          automatically closed in the next few days.

          ---

          <sub>I am a bot reaching out to you with an automated response.</sub>

        stale-issue-label: 'Status ‚ÜØ Stale'
        close-issue-label: 'Status ‚ÜØ Autoclosed'
        exempt-issue-labels: 'feature,Type ‚á¥ Feature,bug,Type ‚á¥ Bug'
        days-before-stale: 30
        days-before-close: 7
        days-before-pr-stale: -1
        days-before-pr-close: -1

  # ---------------------------------------------------------------------------------------
  #   Lock items which have been closed for a long time
  # ---------------------------------------------------------------------------------------

  issues-lock-check:
    name: üîí Lock Closed Submissions
    runs-on: ubuntu-latest
    needs:
      - issues-labels-create
      - issues-labels-check
    steps:
  
    - name: "üîí Lock ‚Ä∫ Inactives"
      uses: dessant/lock-threads@v5
      id: issues-lock-check-run
      with:
        add-pr-labels: 'Status ‚ÜØ Locked'
        add-issue-labels: 'Status ‚ÜØ Locked'
        github-token: ${{ secrets.ADMINSERV_TOKEN }}
        issue-inactive-days: '180'
        issue-lock-reason: 'resolved'
        pr-inactive-days: '365'
        pr-lock-reason: 'resolved'
